# Разработка модуля планирования траектории в заданную точку
Входными данными разрабатываемого модуля являются
- карта местности
- текущее положение робота
- заданная точка
В этом проекте мы будем использовать готовую карту местности и известное положение робота (ground truth от симулятора)
На выходе мы должны получить спланированную траекторию.
Планирование траектории будет реализовано с помощью сетчатой карты без учета кинематики робота. То есть будем планировать траекторию просто по графу, образованному центрами клеток карты.
Входной картой является двумерный массив, известной фиксированной размерности. Каждая клетка этого массива заполнена либо 0, если она свободна от препятствий, либо значением 100, если это препятствие.
Для того, чтобы упростить задачу планирования и не учитывать размеры робота, в начале планирования препятствия карты расширяются на величину половины размера робота (радиус описанной окружности). Таким образом мы получаем пространство конфигураций, в котором можем планировать траекторию для робота. Эта часть задачи уже реализована в проекте, реультаты можно увидеть запустив проект

1. Для запуска как обычно нужно обновить или склонировать заново репозиторий
2. Перейдя в рабочую папку проекта нужно проиницилизировать проект и запустить лонч
```bash
cd mr_ws
source devel/setup.bash
rosaunch simple_planner planner.launch
```
При этом запустится симулятор Stage с заданной картой местности. Также запустится модуль simple_planner и rviz для визуализации и задания целевой точки. riviz запускается с конфигом [simple_planner/launch/planner.rviz](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/launch/planner.rviz), в котором настроно отображение необходимых топиков Изначально в rviz будет отображаться карта местности.
"С помощью инструмента rviz "2d nav goal" мы можем указать на поле карты целевую точку. Она будет опубликована в специальный топик, модуль ее получит и должен выполнить поиск пути. Пока там реализована только расширение препятствий, промежуточная карта с расширенными препятствиями публикуется модулем и мы увидим ее в rviz.

Рассмотрим модуль simple_planner подробнее.
Он реализован в виде класса Planner (planner.h и planner.cpp)
В функции [update_static_map](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L56) реализовано получение карты местности из модуля map_server, который запускается при запуске лонча и предоставляет сервис получения карты.
Также модуль подписан на позицию (ground truth) симулятора - функция [on_pose](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L25) и на топик с заданной точкой [on_target](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L25)
При получении заданной точки происходит обновление исходной карты, увеличение препятствий - вызывается функция [increease_obstacles](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L42), затем запускается алгоритм поиска - функция [calculate_path](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L45)
Если после этого траектория (в виде сообщения path_msg_, представляющего собой массив точек) не пуста - она будет опубликована и отобразится в rviz.
Карта в модуле представлена в виде одномерного массива (std::vector) ячеек размерностью width x geight, где width и height размеры карты, их мы получаем запрашивая карту из map_server.
Из map_server мы получаем карту в виде сообщения [nav_msgs::OccupancyGrid](http://docs.ros.org/en/melodic/api/nav_msgs/html/msg/OccupancyGrid.html), в нем помимо самомго массива хранится также доплнительная информация map_.info(координаты начала карты, разрешение и размеры)
Начальная карта в классе хранится в поле [map_](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L76). Также хранится карта с расширенными препятствиями [obstacle_map_](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L77) и карта с вычисленными стоимстями пути [cost_map_](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L78).
Для реализации поиска задана структура, описывающая вершину графа поиска [SearchNode](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L18): в ней хранится состояние вершины (открыта, закрыта или неопределенное), значение функций стоимости g и эвристики h. При запуске поиска массив SearchNode создается как одномерный массив размера, соотвествующего разрешению исходной карты () и заполняется начальными значениями.
Массивы всех карт и массив узлов поиска имеют одинковую размерности, для работы с ними в классе planner реализованы шаблонные функции [map_value](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L61) для получения ссылки на элемент карты по индексам и функция [point_index](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L67) для получения индексов по координатам точки.
Рассмотрим функцию [increase_obstacles](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L74). Ее входной параметр - это количество клеток на которые нужно расширить препятствие (расчитывается из радиуса робота). В начале функции происходит создание объекта obstacke_map_ : его парамеры такие же как у входной карты, также выделяется память под размер карты(выполняется функция resize для массива ячеек). 

Для расширения используется волновой алгоритм. Индексы клеток, составляющих "волну" помещаются в очередь (std::queue) - переменная [wave](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L81). Изначально в волну помещаются индексы всех клеток, являющихся препятствием, у которых есть хоть один сосед, не являющийся препятствием.  
Затем выполнятеся несколько шагов волны. На каждом шаге препятствия расширяются на одну клетку. То есть число таких шагов равно входному параметру функции.
На каждом шаге создается следующая волна (next_wave). Для каждой клетки из текущей волны в следующую волну добавляются индексы клеток соседей, неявляющихся препятствием. При добавлении в следующую волну в ячейку карты препятствий по соответствующим индексам [прописывается значение, соответствующее препятствию](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L127). В конце цикла, когда в текущей волне все клетки были расширены, волны меняются местами.

Функция calculate_path подготовлена для реализации алгоритма поиска Astar. Для поиска будет использоваться граф, узлы которого хрантся в массиве search_map_. В начале функции массив заполняется неинициализированными узлами.
Для поиска требуется организовать очередь в которую будут помещаться индексы активных узлов графа. Эти узлы должны быть в очереди упорядочены по сумме g+h (стоимость плюс эвристика). Нам потребуется извлекать узлы из начала очереди, удалять существующие узлы и вставлять новые. Такую функциональность предоставляет класс библиотеки стандартных шаблонов [std::set](https://en.cppreference.com/w/cpp/container/set). В нем могут храниться только уникальные оъекты для которых должна быть реализована операция сравнения (Объекты не могут быть равны). При вставке нового объекта - set автоматически переупорядычивает объекты по возрастанию, таким образом, в начале (begin) всегда наименьший объект. В нашем сете мы будем хранить индексы ячеек, и для их сравнения определен класс [CompareSearchNodes](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L141). В нем есть один оператор, который для двух индексов возвращает true, если узел первого индекса меньше, чем узел второго. В данном случае для сравнения используется сумма g+h элемнтов карты поиска, соответствующих индексам. Так как операция сравнения должна быть строгая(равно не возможно), то в случае равенства g+h сравниваются индексы ячеек. 

Перед началом поиска в очередь (set) заносится начальная ячейка. 
Далее начинается цикл поиска: извлекается из очереди ячейка с наименьшим значением g+h (begin).Далее должен быть реализован Astar.


Кратко алгоритм Astar
Функция g для узла - это стоимость достижения узла от начальной точки.
Функция h для узла - это эвристика или оценка стоимости достижения целевой точки от узла

Узлы графа могут быть в трех состояниях; неопределенное(начальное), закрытое(когда все соседи узла исследованы и определено конечное значение g для данного узла), открытое(состояние от того момента как для узла первый раз была посчитана g до того как он становится закрытым)
Алгоритм организует узлы графа, которые нужно исследовать (открытые узлы) в виде очереди, в которой они упорядочены по возрастанию g+h. Изначально все узлы имеют значение g равное бесконечности, кроме узла графа (ячейки карты), соответствующего начальному состоянию. Этот узел становится открытым и помещается в очередь, функция g для него равна нулю. Значение функции h для узла вычисляется в момент вставки в очередь. В этом примере функция вычисления эвристики - это [heruaistic](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L137). она должна возвращать значение оценки достижения целевой точки для заданных индексов узла, наприимер просто расстояние, можно поэкспериментировать с манхеттенской дистанцией. Функция должна быть реализована и использована в Astar.

Основной цикл алгоритма Astar
из очереди извлекается первый элемент (с минимальным g+h)
Этот узел(далее основной) переводится в состояние закрытого и удаляется из очереди, так как сейчас будут исследованы все его соседи.
Для всех соседей основного узла(которые не являются препятствием) вычисляется значение стоимости пути от стартового узла через основной узел: g_new = g + c, где с это стоимость шага до соседа, g - стоимость достижения основного узла. Если вычисленное значение g_new меньше текущего значения g соседа, то этот сосед с новым значением g = g_new и вычисленной эвристикой h = heruistic(индексы соседа) помещается в очередь. (Если он ранее был в очереди - его надо удалить)
Цикл завершается, если элемент, извлеченный из очереди на первом шаге является целевой точкой (путь найден) либо если очередь оказывается пустой (нет пути в заданную точку).
Если путь найден, то мы можем его восстановить, начиная с целевой точки, добавляя к тректории центр соседней клетки, имеющей минимальное значение g.

Функции std::set, которые могут понадобиться.
- [begin()](https://en.cppreference.com/w/cpp/container/set/begin) - возвращает итератор на первый, самый наименьший элемент. Доступ к самому элементу через оператор разименования (`*`)
- [insert](https://en.cppreference.com/w/cpp/container/set/insert) - вставка элемента в очередь. Возвращает пару итератор на вставленный элемент и флаг того, что элемент успешно вставлен (можно вставлять только новый элемент, не равный существующим)
- [erase()](https://en.cppreference.com/w/cpp/container/set/erase) - удаляет элемент из контейнера, в качестве параметра может быть как итератор на элемент, так и сам элемент по значению: будут найден такой элемент и удален, то есть в нашем случае можно удалять по индексам 
- [find](https://en.cppreference.com/w/cpp/container/set/find) - возвращает итератор на элемент с заданным начением, если такой существует, если нет - вернет итератор равный end()
- [size](https://en.cppreference.com/w/cpp/container/set/size) - возвращает размер сета. В процессе выполнения задания у студентов часто возникает ситуация переполнения очереди, когда из очереди не удаляются элементы. Можно распечатать значение этой функции - оно не должно расти в бесконечность.

Обход соседей узла удобно реализовать в виде ranged based for цикла, как в [примере](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L116), здесь neighbors - это массив с индексами соседей, переменная цикла shift поочередно будет принимать значение смещения для каждого соседа. Соседями могут считаться либо 4 ближайшие клетки либо 8. Для диагональных соседей имеет смысл учитывать большую стоимость достижения (sqrt(2.0)).

## Задачи
1. Реализовать волновой алгоритм поиска (в отдельной функции). Также как расширяются прептствия, можно запустить волну, в которую в начале поместить стартовую точку. волна должна расширяться не заходя на препятствия до целевой точки. При этом на каждом шаге необходимо в cost_map записывать увеличивающуюся стоимость. После достижения целевой точки по стоимости сформировать траекторию.
2. Реализовать Astar - дописать функцию calculate_path
3. Применить сглаживание для полученной траектории.