# Разработка модуля планирования траектории в заданную точку
Входными данными разрабатываемого модуля являются
- карта местности
- текущее положение робота
- заданная точка
В этом проекте мы будем использовать готовую карту местности и известное положение робота (ground truth от симулятора)
На выходе мы должны получить спланированную траекторию.
Планирование траектории будет реализовано с помощью сетчатой карты без учета кинематики робота. То есть будем планировать траекторию просто по графу, образованному центрами клеток карты.
Входной картой является двумерный массив, известной фиксированной размерности. Каждая клетка этого массива заполнена либо 0, если она свободна от препятствий, либо значением 100, если это препятствие.
Для того, чтобы упростить задачу планирования и не учитывать размеры робота, в начале планирования препятствия карты расширяются на величину половины размера робота (радиус описанной окружности). Таким образом мы получаем пространство конфигураций, в котором можем планировать траекторию для робота. Эта часть задачи уже реализована в проекте, реультаты можно увидеть запустив проект

1. Для запуска как обычно нужно обновить или склонировать заново репозиторий
2. Перейдя в рабочую папку проекта нужно проиницилизировать проект и запустить лонч
```bash
cd mr_ws
source devel/setup.bash
rosaunch simple_planner planner.launch
```
При этом запустится симулятор Stage с заданной картой местности. Также запустится модуль simple_planner и rviz для визуализации и задания целевой точки. riviz запускается с конфигом [simple_planner/launch/planner.rviz](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/launch/planner.rviz), в котором настроно отображение необходимых топиков Изначально в rviz будет отображаться карта местности.
"С помощью инструмента rviz "2d nav goal" мы можем указать на поле карты целевую точку. Она будет опубликована в специальный топик, модуль ее получит и должен выполнить поиск пути. Пока там реализована только расширение препятствий, промежуточная карта с расширенными препятствиями публикуется модулем и мы увидим ее в rviz.

Рассмотрим модуль simple_planner подробнее.
Он реализован в виде класса Planner (planner.h и planner.cpp)
В функции [update_static_map](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L56) реализовано получение карты местности из модуля map_server, который запускается при запуске лонча и предоставляет сервис получения карты.
Также модуль подписан на позицию (ground truth) симулятора - функция [on_pose](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L25) и на топик с заданной точкой [on_target](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L25)
При получении заданной точки происходит обновление исходной карты, увеличение препятствий - вызывается функция [increease_obstacles](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L42), затем запускается алгоритм поиска - функция [calculate_path](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L45)
Если после этого траектория (в виде сообщения path_msg_, представляющего собой массив точек) не пуста - она будет опубликована и отобразится в rviz.
Карта в модуле представлена в виде одномерного массива (std::vector) ячеек размерностью width x geight, где width и height размеры карты, их мы получаем запрашивая карту из map_server.
Из map_server мы получаем карту в виде сообщения [nav_msgs::OccupancyGrid](http://docs.ros.org/en/melodic/api/nav_msgs/html/msg/OccupancyGrid.html), в нем помимо самомго массива хранится также доплнительная информация map_.info(координаты начала карты, разрешение и размеры)
Начальная карта в классе хранится в поле [map_](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L76). Также хранится карта с расширенными препятствиями [obstacle_map_](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L77) и карта с вычисленными стоимстями пути [cost_map_](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L78).
Для реализации поиска задана структура, описывающая вершину графа поиска [SearchNode](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L18): в ней хранится состояние вершины (открыта, закрыта или неопределенное), значение функций стоимости g и эвристики h. При запуске поиска массив SearchNode создается как одномерный массив размера, соотвествующего разрешению исходной карты () и заполняется начальными значениями.
Массивы всех карт и массив узлов поиска имеют одинковую размерности, для работы с ними в классе planner реализованы шаблонные функции [map_value](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L61) для получения ссылки на элемент карты по индексам и функция [point_index](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.h#L67) для получения индексов по координатам точки.
Рассмотрим функцию [increase_obstacles](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L74). Ее входной параметр - это количество клеток на которые нужно расширить препятствие (расчитывается из радиуса робота). В начале функции происходит создание объекта obstacke_map_ : его парамеры такие же как у входной карты, также выделяется память под размер карты(выполняется функция resize для массива ячеек). 

Для расширения используется волновой алгоритм. Индексы клеток, составляющих "волну" помещаются в очередь (std::queue) - переменная [wave](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L81). Изначально в волну помещаются индексы всех клеток, являющихся препятствием, у которых есть хоть один сосед, не являющийся препятствием.  
Затем выполнятеся несколько шагов волны. На каждом шаге препятствия расширяются на одну клетку. То есть число таких шагов равно входному параметру функции.
На каждом шаге создается следующая волна (next_wave). Для каждой клетки из текущей волны в следующую волну добавляются индексы клеток соседей, неявляющихся препятствием. При добавлении в следующую волну в ячейку карты препятствий по соответствующим индексам [прописывается значение, соответствующее препятствию](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L127). В конце цикла, когда в текущей волне все клетки были расширены, волны меняются местами.

Функция calculate_path подготовлена для реализации алгоритма поиска Astar. Для поиска будет использоваться граф, узлы которого хрантся в массиве search_map_. В начале функции массив заполняется неинициализированными узлами.
Для поиска требуется организовать очередь в которую будут помещаться индексы активных узлов графа. Эти узлы должны быть в очереди упорядочены по сумме g+h (стоимость плюс эвристика). Нам потребуется извлекать узлы из начала очереди, удалять существующие узлы и вставлять новые. Такую функциональность предоставляет класс библиотеки стандартных шаблонов [std::set](https://en.cppreference.com/w/cpp/container/set). В нем могут храниться уникальные оъекты для которых должна быть реализована операция сравнения (Объекты не могут быть равны). При вставке нового объекта - set автоматически переупорядычивает объекты, таким образом, чтобы в начале (begin) наименьший объект. В нашем сете мы будем хранить индексы ячеек, и для их сравнения определен класс [CompareSearchNodes](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/simple_planner/src/planner.cpp#L141). В нем есть один оператор, который для двух индексов возвращает true, если узел первого меньше, чем узел второго. В данном случае для сравнения используется сумма g+h. Так как операция сравнения должна быть строгая(равно не возможно), то в случае равенства g+h сравниваются индексы ячеек. 
Перед началом поиска в очередь заносится начальная ячейка. 
Далее начинается цикл поиска: извлекается из очереди ячейка с наименьшим значением g+h (begin).Далее должен быть реализован Astar.

## Задачи
1. Реализовать волновой алгоритм поиска (в отдельной функции). Также как расширяются прептствия, можно запустить волну, в которую в начале поместить стартовую точку. волна должна расширяться не заходя на препятствия до целевой точки. При этом на каждом шаге необходимо в cost_map записывать увеличивающуюся стоимость. После достижения целевой точки по стоимости сформировать траекторию.
2. Реализовать Astar - дописать функцию calculate_path
3. Применить сглаживание для полученной траектории.