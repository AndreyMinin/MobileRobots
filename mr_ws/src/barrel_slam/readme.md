## Практическое задание №7
### Локализацие МР по особым точкам с помощью EKF SLAM

В этой задаче мы реализуем решение SLAM с помощью EKF (Extended Kalman Filter)

Так же как в предыдущей [задаче](https://github.com/AndreyMinin/MobileRobots/tree/master/mr_ws/src/feature_matcher) будем рассматривать упрощенный вариант, когда в рабочей зоне находятся препятствия, легко выделяемые в скане дальномера (столбики или бочки), которые могут быть использованы как особые точки для локализации. Для определения в каждый момент времени координат этих препятствий-столбов можем ипользовать алгоритм, разработанный в [задаче про scan_matching](https://github.com/AndreyMinin/MobileRobots/tree/master/mr_ws/src/feature_matcher).
Общее число препятствий в рабочей зоне будем считать известным и заранее заданным (здесь их 12).

В этом проекте мы будем определять положение робота и маяков с помощью алгоритма EKF SLAM.

Результат (позиция робота и маяков) будет публиковаться для визуализации в rviz в виде соощений [geometry_msgs::PoseStamped](http://docs.ros.org/en/melodic/api/geometry_msgs/html/msg/PoseStamped.html) (конфиг для rviz уже настроен для их отображения). Также будет публиковаться ветка дерева tf в виде трансоформа от системы координат лазерного дальномера до системы координат карты (map). Не наоборот, чтобы сохранить однонаправленность дерева трансформов: у нас уже есть трансформы, которые мы получаем от симулятора `odom->base_link->scan`. При идеальном определении положения робота будет публиковаться правильный трансформ и в rviz должно корректно отображаться положение робота и маяков при выборе fixed_frame = map.

В проекте потребуется реализовать функцию поиска и добавления маяков по скану дальномера, а также функцию обновления состояния в алгоритме EKF для каждого маяка.

### Описание проекта
Проект реализован в виде класса [Slam](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/barrel_slam/src/slam.h). В классе хранятся различные объекты для работы с ROS (публикаторы результатов, tf броадкастер и пр.), Вектор состояния X, который в нашей задаче ханит позицию робота (x, y, угол) и положения всех маяков (x, y) (размерность 3 + 2 * 12), Матрица-якобиан системы - A, Матрица ковариации ошибок оценок - P. Матрица возмущений(шумов) системы R (3x3) и Q - матрица шумов измерения (2x2) каждого маяка.
new_landmarks - вектор с координатами маяков, найденных в текущем скане в СК дальномера.
last_found_landmark_index - индекс последнего найденного маяка. Эта переменная нужна для инициализации части состояния, относящейся к маяку, котрый мы видим первый раз.
Объект класса подписывается 
- на сообщения одометрии: [on_odo](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/barrel_slam/src/slam.cpp#L6) - сохраняет текущую угловую и линейную скорость..
- на сообщение дальномера: [on_scan](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/barrel_slam/src/slam.cpp#L67), в котором выполняется один цикл алгоритма EKF.
В конструкторе класса выполняется начальная инициализация, заполняются матрцы EKF: положение МР считается нулевым, с нулевой ковариацией, положение маяков неизвестны - соответстующие элементы матрицы ковариации заполняются большими значениями. Матрицы шумов системы и измерений заполняются параметрами из конфига (дефолтные значения выбраны разумными, но возможно потребуется настройка). Матрица ковариации шумов системы отображает неточность нашей модели движения МР, а матрица шумов системы - неточность определения координат маяков с помощью дальномера.

Алгоритм состоит из следующих шагов:
1. Определяем положение маяков в текущем скане ([detect_landmarks](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/barrel_slam/src/slam.cpp#L69)). **Эта функция должна быть реализована** В результате вектор new_landmarks должен быть заполнен координатами найденных маяков.
2. Шаг предсказания predict: выполняется шаг предсказания EKF на момент времени, относящийся к стемпу скана. На основе кинематической модели МР обновляется часть вектора состояния, относящаяся к кординатам робота, вычисляется якобиан системы и обновляется матрица ковариации системы. Эта функция [реализована](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/barrel_slam/src/slam.cpp#L164)
3. Для каждого найденного маяка ищем индекс соответствующего маяка в состоянии - [associate_measurement](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/barrel_slam/src/slam.cpp#L33). Эта функция реализована - она осуществляет поиск ближайшего маяка в состоянии (координаты маяков хранятся в векторе состояния последовательно, `X.segment(3 + i*2, 2)` - функция Eigen, возвращающая сегмент вектора состояния, относящийся к i-ому маяку). Если расстояние до ближайшего маяка меньше определенного порога, то считаем, что мы нашли индекс. Иначе возвращается -1.
4. Если маяк в скане - один из тех, которые мы уже видели (его координаты в стейте и матрица ковариации инициализирована), тогда производим коррекцию EKF по этому измерению (по одному маяку) - вызывается функция [correct](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/barrel_slam/src/slam.cpp#L64), **которая должна быть реализована**.
5. Если найденный маяк не имеет ассоциаций, то добавляем его в стейт: инициализирем начальное положение координатами маяка в СК карты и соответствующие элементы матрицы ковариации - [add_landmark_to_state](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/barrel_slam/src/slam.cpp#L52). Эта функция **также должна быть реализована**
6. В конце публикуются результаты и трансформ в tf.

### Запуск
Запуск осуществляется (после сборки и инициализации рабочей папки) с помощью команды:
```bash
roslauch barrel_slam slam.launch
```
Запустится симулятор, контроллер для движения МР по заданному треку, модуль EKF SLAM - barrel_slam и rviz для визуализации маяков и робота.

### Задача
Реалиовать EKF SLAM на базе проекта barrel_slam. Результатом можно считать устойчивое определение положения робота и маяков - корректное отображение в rviz при заданном fixed_frame = map