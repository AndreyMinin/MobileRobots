## Практическое задание №5  
### Локализация мобильного робота по особенным точкам
В этой задаче должен быть реализован метод локализации МР, оснащенного лазерным дальномером, основанный на сопоставлении сканов (scan matching). 

При запуске МР движется под управлением simple_controller по заданной траектории. При этом результаты решения этой задачи локализации не используются (используется ground_truth от симулятора), то есть МР в любом случае будет двигаться. При успешном решении задачи локализации это можно исправить.

Для того, чтобы задача не была очень сложной, будем рассматривать упрощенную постановку задачи. МР движется в рабочей зоне, в которой препятствия - столбики, которые легко выделяются в скане лазерного дальномера и могут быть использованы как особые точки для сопоставления двух сканов и определения перемещения МР между ними.

Задача сводится к определению положения робота в виде преобразования (трансформа) между начальной СК, совпадающей с СК карты и СК мобильного робота, совпадающей с СК дальномера.

При решении этой задачи не будут использоваться вероятностные методы для оценок положения робота.


Выделение опорных точек из скана - задача определения координат центров столибков по данным дальномера. Так как препятствия, попадающие в область видимости дальномера - это только сами столбики, то их выделение возможно простым геометрическим способом: для каждого препятствия-столбика надо в скане определить индексы лучей, попадающих в столб. Это можно сделать по изменению дальности лучей: лучи, попадающие в один столб идут подряд и имеют похожее значение дальности, меньшее максимальной дальности дальномера. Столбы расположены не ближе метра друг к другу, поэтому можно считать, что изменение дальности в скане больше этого порога - признаки первого и последнего лучей, упирающихся в столб. Все лучи между ними принадлежат одному столбу, если среди них найти луч с наименьшей дальностью и добавить к нему радиус столба(0.55), то можно считать, полученную точку (угол наименьшего луча, радиус наименьшего луча + радиус столба) координатами центра столба.

После того как особенные точки двух сканов выделены - можем найти преобразование(перенос и поворот) между этими двумя сканами. При вычисилении преобразования необходимо знать какая особенная точка одного скана какой особенной точке второго скана соответствует. Здесь эта задача может быть решена просто за счет расстояниямежду разными точками. То есть соответствие точек определяется по расстоянию - ближашие опорные точки двух сканов считаются соответствующими (парными) (тут будет необходим какой-то порог по расстояниию, чтобы не создать неверные пары). По выделенным парам соответствующих точек определяется преобразование между опорным и текущим сканом через svd разложение. (Определение преобразования уже реализовано в проекте).

Определение перемещения будет осуществляться в локальной системе координат, привязаннной к начальному положению робота. Каждый раз мы будем определять положение нового скана (новых опорных точек, выделенных из скана) относительно особенных точек, выделенных из некоторого скана, полученного ранее - *опорного* скана. В начальный момент первый полученный скан и его особенные точки становятся опорными. Замена опорного скана (его особых точек) на новый скан будет происходить периодически, таким образом, чтобы по выделенным точкам нового и опорного скана можно было определять перемещение (должно быть не менее 2 общих точек). Тут возможны разные стратегии: 
- замена опорного скана каждым новым сканом (это приведет к чуть большей ошибке, так как ошибка определения положения робота будет накапливаться быстрее), 
- замена опорного скана после проезда определенного расстояния (поворота на определенный угол). Расстояние должно быть подобрано так, чтобы у опорного и нового скана всегда было достаточное количество общих точек для вычисления преобразования.
- замена опорного скана только тогда, когда число общих особенных точек в опорном и новом скане не упадет ниже порога. Этот вариант немного сложнее, тем, что, когда число общих особенных точек падает ниже порога, мы уже не сможем определить преобразование между сканами, поэтому каждый скан (его опорные точки), для которого удалось найти преобразование придется сохранять как возможный новый опорный скан. И если для нового скана не удалось найти преобразование относительно опорного, то нужно опорный скан заменить и повторить вычисление преобразования для нового скана.

Для того, чтобы упростить поиск преобразования, а также упростить поиск соответствующих опорных точек для каждого нового скана, будем использовать в качестве начального преобразования не только предыдущее преобразование, но и предсказание. В качестве предсказания будем "добавлять" последнее изменение трансформа, то есть будем считать, что робот продолжит двигаться с той же линейной и угловой скоростью, что и на предыдущем шаге. (В коде "добавление" просиходит "слева", так как изменение трансформов рассматривается в СК карты)

### Описание проекта feature_matcher
feature_matcher проект-загатовка для реализации задачи.  

В модуле для работы с координатами и матрицами используется библиотка Eigen:
- Eigen::Vector2d - двуменый вектор координат (точки)
- Eigen::Isometry2d - матрица для преобразований в 2d, то есть трехмерная матрица, состоящая из матрицы поворота (2х2) и вектора переноса.

В Eigen реализованы практически все операции между векторами и матрицами(преобразованиями). То есть, вектора можно складывать умножать скалярно и векторно, чтобы преобразовать вектор Eigen в другую СК, нужно умножить (оператор `*`) матрицу преобразования на вектор. В результате будет получен вектор в новой СК.

Модуль реализован в виде класса, одна из функции которого подписана на сообщения сканирующего дальномера: [on_laser_scan](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/feature_matcher/src/matcher.cpp#L4). Это основная функция, в которой происходит вся работа модуля (вызываются остальные функции).

В классе хранится 
- `base_features` - вектор с координатами особенных точек опорного скана в СК карты;
- `new_features` - вектор с координатами особенных точек нового полученного скана в СК дальномера -  (т.е. это центры столбов в текущем скане, преобразованные в декартову СК скана);
- `predicted_features` - вектор с координатами особенных точек нового скана, преобразованными в СК карты с учетом предсказанного положения МР;
- `feature_pair_indices` - вектор с индексами особенных точек нового скана, соответствующими особенным точками опорного скана. Длина этого вектора равна длине вектора с координатами особенных точек опорного скана (base_features) и i-ый элемент содержит индекс особенной точки нового скана(new_features), которая соответствует i-ой особенной точки опорного скана. Если нет соответствия - элемент равен (-1).
- `transform` - вычисленное преобразование от текущего скана в СК карты. То есть это преобразование с помощью которого точки в СК скана можно перевести в СК карты: Xmap = transform * Xlaser
- `incremental_transform` - преобразование между двумя последними положениями МРб заданное в СК карты: `transform(t+1) = incremental_transform*transform(t)`;
- `br` - объект, необходимый для публикации трансформов tf map->laser. 
- другие переменные, необходимые для взаимодействия с ROS: `feature_pub` - публикатор особенных точек, `odo_pub`- публикатор лазерной одометрии.

Рассмотрим функции, вызываемые из on_laser_scan
- `detect_features` - функция, которая должна быть реализована - определение особенных точек (центров столбов) по скану дальномера как было описано выше. Предполагается, что здесь будет цикл, в котором будут определены начальный и конечный индексы для каждого наблюдаемого столба и для этих индексов вызывается функция [add_feature](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/feature_matcher/src/matcher.cpp#L36). Внутри add_feature определяется центр стоба и его координаты добавляются в вектор new_features в СК дальномера.
- `publish_features` - функция, котрая публикует найденные центры столбов в ROS, чтобы с помощью rviz можно было убедиться в корректности определения особенных точек
- `predict_features_poses` - функция, которая должна пересчитывать координаты new_features в СК карты с учетом предсказания трансформа в вектор predicted_features. По сути здесь нужно добавить цикл, в котором predicted_features[i] = interpolated_transfrom * new_features[i];
- `find_feature_pairs` - функция ищет соответствия между base_features и preidicted_features по расстоянию и заполняет вектор индексов соответтсвий feature_pair_indices (функция уже реализована)
- `find_transform` - функция определяющая трансворм для текущего скана: перемещение и вращение, котрые переводят predicted_features наиболее близко к base_features. Для этого ищется трансформ между парами predicted_features и base_features в СК карты с помощью svd разложения. С помощью полученного трансформа(result_transform) [обновляется incremental_transform](https://github.com/AndreyMinin/MobileRobots/blob/master/mr_ws/src/feature_matcher/src/matcher.cpp#L129) и transform. (Эта функция уже реализована)
- `update_base_features` - функция обновления базовых особых точек. Тут надо добавить код с проверкой условия, по которому базовые особые точки должны поменяться на новые в СК координат карты (нужен пересчет с учетом transform). Проще всего организовать обновление по пройденному расстоянию (`incremental_transform.translation().norm()`)
- `publish_transform` - функция, которая публикует результаты: одометрию по дальномеру и трансформ tf

После сборки и инициализации воркспейса можно запустить проект:
```
roslaunch feature_matcher matcher.launch
```
Запустится симулятор stage, модуль feature_matcher, контроллер для того. чтобы робот двигался, и rviz для наблюдения результатов.

 В настроенном профиле rviz результаты отображаются в СК odom - это СК groud_truth симулятора, поэтому в ней мы видим корректное отображение положения робота в виде осей и данные дальномера - точки на столбах. Столбы при движении остаются на месте.
После того как будет реализована функция определения detect_features в rviz будут отображаться в виде маркеров найденные центры столбов. Нужно убедиться, что они соответствуют данным дальномера.

После того, как будет реализована остальная часть программы ее работоспособность можно проверить, если в настройках rviz на левой панели выбрать Global Options -> Fixed Frame -> map. Если программа реализована верно, то в выбранном фрейме робот должен перемещаться, а столбы оставаться на своих местах, также как и в odom.

Так как при определении положения используются особенные точки, которые время от времени обновляются и при этом неизбежно накапливается ошибка, со временем положение СК map может медленно смещаться относительно odom.

## Задача
1. Реализовать функцию detect_features, чтобы правильно определялись центры столбов
2. Релизовать остальные функции, чтобы определялось положение МР по данным дальномера